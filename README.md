# ITMO-IS-Algorithms-and-Data-Structures-2nd-semester-summary
Graphs and strings, конспект на Русском, код нет.<br>
Конспект чисто для себя, поэтому некоторые простые объяснения
(DFS, BFS, TPS) опущены.

# Алгоритмы на графах
## DFS
### [Code](lib/dfs.cpp)
### Описание
Известен также, как обход в глубину. Используется в многих алгоритмах.
С помощью него можно, например, определить компоненты связности или
сделать топологическую сортировку.</br>
### Асимптотика
Выводится из двух вещей:
- Обход всех вершин - O(|V|)
```c++
while (!visited[id]) {
    DFS(...)
}
```
- Обход всех элементов, которые хранят эти вершины
```c++
for (auto& i : graph[id]) {
    ...
}
```
В зависимости от типа хранения меняется асимптотика второго обхода
- Для списка смежности (каждая вершина хранит только вершины, в которые она ведет)</br>
  O(|E|)
- Для матрицы смежности (булева таблица, каждая вершина хранит
  список всех вершин, если она ведет в V<sub>i</sub> - то элемент i = true, иначе false)</br>
  O(|V|<sup>2</sup>), тк для каждой V мы делаем V проходов
- Для матрицы инцидентности (булева таблица, каждая вершина хранит
  список всех ребер, если она вершина смежна с E<sub>i</sub> - то элемент i = true, иначе false)</br>
  O(|V| * |E|), тк для каждой V мы делаем E проходов

Итого асимптотика O(1п + 2п), т.е. для матрицы смежности:<br>
O(|V| + |E|),<br>
Для матрицы смежности:<br>
O(|V| + |V|<sup>2</sup>) = O(|V|<sup>2</sup>),<br>
Для матрицы инцидентности:<br>
O(|V| + |V| * |E|) = O(|V| * |E|)

## BFS
### [Code](lib/bfs.cpp)
### Описание
Известен также, как обход в ширину. Используется в многих алгоритмах.
С помощью него можно, например, определить компоненты связности.
Отличие от DFS - тип обхода. Часто они взаимозаменяемые,
но есть и исключения.
### Асимптотика
Аналогична DFS

## Проверка графа на наличие цикла и его восстановление
### [Code](lib/find_cycle.cpp)
### Описание
Используем рекурсивный DFS для обхода. Помечаем вершину одним из
трех цветов:
- 0, если вершина не была посещена (цвет по умолчанию)
- 1, если мы рекурсивно вошли в вершину
- 2, если рекурсивно вышли

Если в результате мы получим ситуацию, когда встретили вершину, из которой рекурсивно
не вернулись:
```c++
if (color[i] == 1) {
    ...
}
```
то добавим эти две вершины как начало и конец цикла, пройдемся
задом наперед по массиву родителей, пока не придем во вторую вершину, ответ
развернем (тк проходили в обратном порядке)
### Асимптотика
См. DFS

## Топологическая сортировка
### [Code](lib/tps.cpp)
### Описание
Сортировка вершин в топологическом порядке, т.е.
для любой пары вершин выполняется условие:<br>
Для любого ребра E(V<sub>i</sub> -> V<sub>j</sub>), i < j.<br>
Следуя из определения, граф должен быть ориентированным и ациклическим.
### Асимптотика
- Проверка на ацикличность займет O(DFS)
- Работа алгоритма займет O(DFS)
- Итого O(2DFS) = O(DFS)

Если опустить проверку на ацикличность, на асимптотику это не повлияет,
только на константу.

## Поиск компонент сильной связности (Алгоритм Косараю)
### [Code](lib/kosaraju.cpp)
### Описание
Компонента сильной связности - множество вершин, в котором любые две
вершины сильно связаны.<br>
Вершины V<sub>i</sub> и V<sub>j</sub> сильно связаны, если существует
путь V<sub>i</sub> -> V<sub>j</sub> и одновременно V<sub>j</sub> ->
V<sub>i</sub>.
Порядок работы:
1. Использует псевдо-TPS (т.к. граф, конечно, ориентированный, но,
   очевидно, не ациклический (просто запоминаем порядок выхода из DFS))
2. Инвертирует ребра (можно объединить с прошлым пунктом для улучшения константы)
3. Создает массив visited
4. Если вершина не посещена -
   - Добавляет новую компоненту сильной связности в выходной массив,
     запускает DFS, в процессе добавляя вершины в последний элемент
     выходного массива, удаляет вершину из стека
   
   Иначе -
   - Удаляет из стека

Выходной массив и является массивом всех компонент сильной связности.
### Асимптотика
- Псевдо-TPS займет O(DFS)
- Инвертирование ребер займет O(DFS)
- Добавление в выходной массив займет O(DFS)

Итого - O(DFS)

## Конденсация графа
### [Code](lib/condensation.cpp)
LATER

## Поиск Гамильтонова цикла при выполнении достаточных условий (теоремы Дирака или Оре)
При соблюдении теоремы Оре
$`deg(V{i}) ≥ \frac{n}{2}`$,
или Дирака
$`deg(V{i}) + deg(V{j}) ≥ n`$, 
где $V{i}$, $V{j}$ - любые две вершины, а $deg(V)$ - степень вершины.

### [Code](lib/find_hamiltonian_cycle.cpp)
### Описание
Гамильтонов цикл - замкнутый путь, который проходит по всем вершинам графа и только 
один раз<br>
Разберем алгоритм построчно:
```c++
std::vector<unsigned long> q(graph.size());
for (unsigned long i = 0; i < graph.size(); ++i) {
    q[i] = i;
}
```
Здесь создается так называемая "очередь" (хотя это и массив), которая содержит все
вершины графа (порядок произвольный).
```c++
for (unsigned long c = 0; c < graph.size() * (graph.size() - 1); ++c) {
    ...
}
```
Этот цикл |V| * (|V| - 1) раз (magic number, откуда берется не знаю), иногда он будет работать за единицу,
иногда за n. Оба случая рассмотрим.
```c++
if (!graph[q[0]][q[1]]) {
    unsigned long i = 2;
    while (i < q.size() - 1 && (!graph[q[0]][q[i]] || !graph[q[1]][i + 1])) {
        ++i;
    }
    std::reverse(q.begin() + 1, q.begin() + i + 1);
}
q.push_back(q[0]);
q.erase(q.begin());
```
Тут мы ищем две соседних вершины, у которых нет смежности. Если попались такие вершины,
то ищем, с какими есть смежность, затем разворачиваем подотрезок от 1 до i
(либо V<sub>0</sub> смежно с V<sub>i</sub>, либо V<sub>1</sub> смежно с V<sub>i+1</sub>).
Таким образом, каждый раз выполняя reverse, мы добавляем минимум 1 смежную вершину.
Следовательно, эта операция будет происходить не больше |V| раз, работает она за O(|V|).<br>
Операция добавления в конец работает за O(1).

### Асимптотика
- Асимптотика цикла - O(|V|<sup>2</sup>)
- Асимптотика reverse - O(|V|). Reverse выполняется |V| раз, значит общая асимптотика
  таких операций O(|V|<sup>2</sup>).
- Общая асимптотика O(|V|<sup>2</sup> - |V| + |V|<sup>2</sup>) = O(2 * |V|<sup>2</sup>) =<br>
  O(|V|<sup>2</sup>).

> [!WARNING]
> Реализовывать алгоритм лучше на <i>матрице</i> смежности, иначе проверка на наличие ребра
> между вершинами увеличит асимптотику еще в |E| раз. Т.е. асимптотика на списке смежности
> и матрице инцидентности:<br>
> O(|V|<sup>2</sup> * |E| - |V| * |E| + |V|<sup>2</sup> * |E|) = O(|V|<sup>2</sup> * |E|)

## Поиск Эйлерова цикла
### [Code](lib/find_euler_cycle.cpp)
### Описание
Эйлеров цикл - замкнутый путь, проходящий по всем ребрам графа и только один раз.<br>
Для начала нужно проверить критерий эйлеровости графа:
- Степень каждой вершины (сумма входящих и исходящих в граф ребер для ориентированного графа) - четная.
- Все компоненты связности, кроме, может быть, одной не имеют ребер.

После проверки необходимо построить Эйлеров цикл.
Идем по ребрам V<sub>i</sub> вершины. Если у этой вершины есть неиспользованные ребра,
то помечаем ребро пройденным, добавляем смежную вершину в стек. Если таковых нет, 
удаляем верхнюю вершину из стека и добавляем ее в ответ.
### Асимптотика
- Проверка на эйлеровость занимает:
  - O(|V|) на проверку степеней
  - O(DFS) на проверку наличия элементов в компонентах связности.
  
  Итого - O(|V| + DFS) = O(DFS)
- Алгоритм работает за O(mark_edge * find_adjacent_vertex * |E|), т.к. мы проходимся по всем ребрам,
  находим и помечаем ребро и добавляем смежную вершину в стек. При правильной реализации:<br>
  - O(mark_edge) = O(find_adjacent_vertex) = O(1), весь алгоритм - O(|E|),<br>
  
  однако это требует доп. памяти (см. рекурсивную реализацию алгоритма за O(|E|)).

## Нахождение компонент связности в неориентированном графе
См. DFS или BFS

## Алгоритм Краскала
### [Code](lib/kraskal.cpp)
### Описание
Построить МСТ графа. МСТ - минимальное остовное дерево = остовное дерево, имеющее
минимально возможный вес, где вес дерева = сумма весов входящих в него ребер.<br>
Сначала мы сортируем ребра в порядке возрастания их весов.<br>
Затем разбиваем вершины на множества. По умолчанию - |V| множеств, состоящих
из одной вершины.<br><br>
Затем проходимся по отсортированному списку рёбер.<br>Проверяем, если смежные этому ребру
вершины находятся в разных множествах: 
- Добавляем ребро в ответ, множества сливаем.

Иначе -
- Пропускаем ребро

После того как мы прошли по всем ребрам, возвращаем ответ.

### Асимптотика
Общий вид - O(sort + init_union + |E| * find_union_parent * merge_union).<br>
При стандартной реализации используется СНМ, т. е. асимптотика find_union_parent =
merge_union = O(α(m, n)), где α - функция, обратная к функции Аккермана, которую
можно принять за константу, тк она принимает значения ⩽ 4.<br>
Однако, init_union (создание СНМ) - O(|E|).<br>
Итоговая асимптотика - O(sort + |E| + |E|) = O(sort + |E|)
> [!WARNING]
> Говорят, существуют проверяющие, которые дают задание придумать Краскала за
> O(|E|). Не забывайте, что существует сортировка подсчётом, работающая за O(n),
> т.е. за O(|E|).<br>То есть итоговая асимптотика O(sort + |E|) = O(|E| + |E|) = O(|E|)

## СНМ
### Описание
> [!NOTE]
> Вообще, СНМ нет в чек-листе, но если доказывать Краскала (или др. алгоритмы) с ним,
> скорее всего попросят пояснить.

СНМ - система непересекающихся множеств. Это - иерархическая структура данных,
позволяющая эффективно работать с множествами.<br>
Есть всего две операции - find и union.
- Если find(x) == find(y), то элементы лежат в одном множестве.
- Union(x, y) - объединить множества, в которых лежат элементы x и y.
  При реализации без эвристик, асимптотика find = O(1), а асимптотика
  Union = O(n)
- init = O(n)

#### Эвристики
Представим наше множество в виде корневого дерева, тогда СНМ - лес корневых деревьев.
Тогда, каждый раз выполняя merge, мы можем просто "подвязывать" корень одного дерева.
В таком случае, асимптотика merge = O(find), а O(find) = O(h), где h - высота дерева.<br>

Есть 3 вида эвристик (упрощения, ускорения) - 
- Ранговая
- Сжатия путей
- Весовая
#### Ранговая эвристика
Подвешиваем дерево с меньшей глубиной к дереву с большей глубиной.
Доказывается, что максимальный ранг ⩽ log(n), т.е. если не использовать другие
эвристики, то<br>
find = O(log(n))
#### Сжатия путей
Когда мы ищем родителя элемента, мы можем переподвесить элементы напрямую к корню,
таким образом уменьшая средний случай поиска родителя и ускоряя find, притом чем чаще
мы вызываем find, тем быстрее работает наше дерево.
Доказывается, что не используя другие эвристики:<br>
$$O(find) = O(\frac{log(\frac{n^2}{m})}{log(\frac{m}{n})}) = O(log(n))$$
#### Разбор асимптотики сжатия путей
n - число элементов, m - число операций.<br>
$`f(n, m) = \frac{log(\frac{n^2}{m})}{log(\frac{m}{n})}`$ - эта функция показывает, что
чем больше наше m, тем меньше выйдет итоговая асимптотика. Например, при m ≈ n,
f(n, ~n) ≈ log(n).<br>А уже при m ≈ n$`\sqrt(n)`$, f ≈ 1.
#### Асимптотика, используя эти два случая одновременно
find = merge = O(α(m, n)), где α(m, n) - функция, обратная к функции Аккермана,
α(m, n) ⩽ 4, что можно принять за константу.
#### Весовая эвристика
Очень схожа с ранговой, однако вместо высоты поддерева храним "вес" дерева, те
количество вершин входящих в него. Асимптотика совпадает с асимптотикой ранговой
эвристики. Также можно использовать вместе со сжатием путей, получая ту же
выходную асимптотику.
## Алгоритм Прима
### [Code](lib/prima.cpp)
### Описание
Алгоритм поиска MST. Для каждой вершины храним массив "ключей" (key, вес минимального ребра,
смежного с этой вершиной) и "предыдущих вершин" (prev, вершин, из которых исходит ребро,
вес которого является "ключом" этой вершины).<br>
Начнем алгоритм со стартовой вершины: для нее определим ключ 0 и предыдущую вершину
за null. Пройдемся по всем ребрам, смежным с ней:<br>
Если вес(w) ребра (i -> j) < key[j], то key[j] = w, а prev[j] = i. Так мы выбрали это
ребро как минимальное для вершины j.<br>
Затем ищем вершину с минимальным ключом, удаляем ее из списка вершин, которые можно
использовать, и повторяем проход по ребрам еще |V| - 1 раз. На выходе
получаем массив prev, из которого можно получить MST.
### Асимптотика
- Этот алгоритм работает за O(|V| * extract_min + |E| * decrease_key), т.к. мы |V| раз
  ищем вершину с минимальным ключом и максимум |E| раз этот ключ меняем.
- Для плотных графов рекомендуется оставить линейный поиск минимального ключа (extract_min
  = O(|V|)), тогда decrease_key будет происходить за O(1).<br>
  В таком случае асимптотика будет O(|V| * |V| + |E| * 1) = O(|V|<sup>2</sup> + |E|)<br>
  Т. к. граф плотный, то O(|E|) = O(|V|<sup>2</sup>) => итоговая асимптотика = O(|V|<sup>2</sup>).
- Для разреженных графов рекомендуется использовать приоритетную очередь (в данном случае
  на двоичной куче), т. к. в таком случае extract_min = decrease_key = O(log(|V|))
  (log(|V|) т. к. мы храним именно вершины).<br>
  Тогда асимптотика O(|V| * log(|V|) + |E| * log(|V|)).<br>
  O(|E|) >= O(|V|) => O(|V| * log(|V|) + |E| * log(|V|)) = O(2 * |E| * log(|V|)) =
  O(|E| * log(|V|)).
- Есть вариант с использованием фиб. кучи, в которой extract_min = O(log(|V|)),
  а decrease_key = O(1), тогда асимптотика сводится к<br>
  O(|V| * log(|V|) + |E|)

## Алгоритм Беллмана-Форда
### [Code](lib/bellman_ford.cpp)