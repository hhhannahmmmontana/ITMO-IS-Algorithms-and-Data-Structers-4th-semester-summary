# ITMO-IS-Algorithms-and-Data-Structers-4th-semester-summary
Graphs and strings, конспект на Русском, код нет.<br>
Конспект чисто для себя, поэтому некоторые простые объяснения
(DFS, BFS, TPS) опущены.

# Graph
## DFS:
### [Code](lib/dfs.cpp)
### Описание
Известен также, как обход в глубину. Используется в многих алгоритмах.
С помощью него можно, например, определить компоненты связности или
сделать топологическую сортировку.</br>
### Асимптотика
Выводится из двух вещей:
- Обход всех вершин - O(|V|)
```cpp
while (!visited[id]) {
    DFS(...)
}
```
- Обход всех элементов, которые хранят эти вершины
```cpp
for (auto& i : graph[id]) {
    ...
}
```
В зависимости от типа хранения меняется асимптотика второго обхода
- Для списка смежности (каждая вершина хранит только вершины, в которые она ведет)</br>
  O(|E|)
- Для матрицы смежности (булева таблица, каждая вершина хранит
  список всех вершин, если она ведет в V<sub>i</sub> - то элемент i = true, иначе false)</br>
  O(|V|<sup>2</sup>), тк для каждой V мы делаем V проходов
- Для матрицы инцидентности (булева таблица, каждая вершина хранит
  список всех ребер, если она вершина смежна с E<sub>i</sub> - то элемент i = true, иначе false)</br>
  O(|V| * |E|), тк для каждой V мы делаем E проходов

Итого асимптотика O(1п + 2п), т.е. для матрицы смежности:<br>
O(|V| + |E|),<br>
Для матрицы смежности:<br>
O(|V| + |V|<sup>2</sup>) = O(|V|<sup>2</sup>),<br>
Для матрицы инцидентности:<br>
O(|V| + |V| * |E|) = O(|V| * |E|)

## BFS:
### [Code](lib/bfs.cpp)
### Описание
Известен также, как обход в ширину. Используется в многих алгоритмах.
С помощью него можно, например, определить компоненты связности.
Отличие от DFS - тип обхода. Часто они взаимозаменяемые,
но есть и исключения.
### Асимптотика
Аналогична DFS

## Проверка графа на наличие цикла и его восстановление
### [Code](lib/find_cycle.cpp)
### Описание
Используем рекурсивный DFS для обхода. Помечаем вершину одним из
трех цветов:
- 0, если вершина не была посещена (цвет по умолчанию)
- 1, если мы рекурсивно вошли в вершину
- 2, если рекурсивно вышли

Если в результате мы получим ситуацию, когда встретили вершину, из которой рекурсивно
не вернулись:
```cpp
if (color[i] == 1) {
    ...
}
```
то добавим эти две вершины как начало и конец цикла, пройдемся
задом наперед по массиву родителей, пока не придем во вторую вершину, ответ
развернем (тк проходили в обратном порядке)
### Асимптотика
См. DFS

## Топологическая сортировка
### [Code](lib/tps.cpp)
### Описание
Сортировка вершин в топологическом порядке, т.е.
для любой пары вершин выполняется условие:<br>
Для любого ребра E(V<sub>i</sub> -> V<sub>j</sub>), i < j.<br>
Следуя из определения, граф должен быть ориентированным и ациклическим.
### Асимптотика
- Проверка на ацикличность займет O(DFS)
- Работа алгоритма займет O(DFS)
- Итого O(2DFS) = O(DFS)

Если опустить проверку на ацикличность, на асимптотику это не повлияет,
только на константу.

## Поиск компонент сильной связности (Алгоритм Косараю)
### [Code](lib/kosaraju.cpp)
### Описание
Компонента сильной связности - множество вершин, в котором любые две
вершины сильно связаны.<br>
Вершины V<sub>i</sub> и V<sub>j</sub> сильно связаны, если существует
путь V<sub>i</sub> -> V<sub>j</sub> и одновременно V<sub>j</sub> ->
V<sub>i</sub>.
Порядок работы:
1. Использует псевдо-TPS (т.к. граф, конечно, ориентированный, но,
   очевидно, не ациклический (просто запоминаем порядок выхода из DFS))
2. Инвертирует ребра (можно объединить с прошлым пунктом для улучшения константы)
3. Создает массив visited
4. Если вершина не посещена -
   - Добавляет новую компоненту сильной связности в выходной массив,
     запускает DFS, в процессе добавляя вершины в последний элемент
     выходного массива, удаляет вершину из стека
   
   Иначе -
   - Удаляет из стека

Выходной массив и является массивом всех компонент сильной связности.
### Асимптотика
- Псевдо-TPS займет O(DFS)
- Инвертирование ребер займет O(DFS)
- Добавление в выходной массив займет O(DFS)

Итого - O(DFS)

## Конденсация графа
### [Code](lib/condensation.cpp)
LATER

## Поиск Гамильтонова цикла при выполнении достаточных условий (теоремы Дирака или Оре)
При соблюдении теоремы Оре
$`deg(V{i}) ≥ \frac{n}{2}`$,
или Дирака
$`deg(V{i}) + deg(V{j}) ≥ n`$, 
где $V{i}$, $V{j}$ - любые две вершины, а $deg(V)$ - степень вершины.
